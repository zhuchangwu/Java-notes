<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>多线程六 同步容器&amp;并发容器 | blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="同步容器(使用的是synchronized,并且不一定是百分百安全) 本篇续  – 线程之间的通信  ,介绍java提供的并发集合,既然正确的使用wait和notify比较困难,java平台为我们提供了更高级的并发容器来替代">
<meta name="keywords" content="多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程六 同步容器&amp;并发容器">
<meta property="og:url" content="http://yoursite.com/2019/01/22/多线程六 同步容器&并发容器/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:description" content="同步容器(使用的是synchronized,并且不一定是百分百安全) 本篇续  – 线程之间的通信  ,介绍java提供的并发集合,既然正确的使用wait和notify比较困难,java平台为我们提供了更高级的并发容器来替代">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-03-04T12:48:45.150Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多线程六 同步容器&amp;并发容器">
<meta name="twitter:description" content="同步容器(使用的是synchronized,并且不一定是百分百安全) 本篇续  – 线程之间的通信  ,介绍java提供的并发集合,既然正确的使用wait和notify比较困难,java平台为我们提供了更高级的并发容器来替代">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="https://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
  
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="/img/headportrait.jpg" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">赐我白日梦</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories">分类</a></li>
				        
							<li><a href="/archives">归档</a></li>
				        
							<li><a href="/about">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="http://github.com/zhuchangwu" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/Elasticsearch/" style="font-size: 12.5px;">Elasticsearch</a> <a href="/tags/Hibernate-Validator/" style="font-size: 10px;">Hibernate-Validator</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/JavaScript/" style="font-size: 12.5px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Oracle/" style="font-size: 17.5px;">Oracle</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Redis/" style="font-size: 12.5px;">Redis</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/SpringMvc/" style="font-size: 12.5px;">SpringMvc</a> <a href="/tags/Thymeleaf/" style="font-size: 10px;">Thymeleaf</a> <a href="/tags/java/" style="font-size: 17.5px;">java</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/多线程/" style="font-size: 20px;">多线程</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.voidking.com">VoidKing</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jianshu.com/u/9f179465dd2b">简书</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://segmentfault.com/blog/voidking">SegmentFault</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/voidking">博客园</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/c0416">CSDN</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.iots.vip">Alliot&#39;s Blog</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">虽然还没想好怎么夸自己，但总觉得这里放点东西比较和谐。。。</div>
				</section>
				
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">赐我白日梦</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/headportrait.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">赐我白日梦</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories">分类</a></li>
		        
					<li><a href="/archives">归档</a></li>
		        
					<li><a href="/about">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="http://github.com/zhuchangwu" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-多线程六 同步容器&amp;并发容器" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/22/多线程六 同步容器&并发容器/" class="article-date">
  	<time datetime="2019-01-22T13:52:06.000Z" itemprop="datePublished">2019-01-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      多线程六 同步容器&amp;并发容器
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/多线程/">多线程</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">	
      
	  
		
		
        <h3 id="同步容器-使用的是synchronized-并且不一定是百分百安全"><a href="#同步容器-使用的是synchronized-并且不一定是百分百安全" class="headerlink" title="同步容器(使用的是synchronized,并且不一定是百分百安全)"></a>同步容器(使用的是synchronized,并且不一定是百分百安全)</h3><blockquote>
<p><strong>本篇续  – 线程之间的通信  ,介绍java提供的并发集合,既然正确的使用wait和notify比较困难,java平台为我们提供了更高级的并发容器来替代</strong><a id="more"></a></p>
</blockquote>
<h3 id="一-Vector-amp-ArrayList"><a href="#一-Vector-amp-ArrayList" class="headerlink" title="一.  Vector&amp;ArrayList"></a>一.  Vector&amp;ArrayList</h3><ul>
<li>Vector虽然它的set和get方法都被Synchronized修饰,但是开启两条线程并发访问,一条线程拼命往里写,另一台循环往移除,这样并发访问不一定是百分百的线程安全的,很可能出现数组越界异常,而且现在基本已经不适用它了,它基本被ArrayList替代掉了</li>
<li>ArrayList是线程不安全的</li>
</ul>
<p>将ArrayList转换成线程安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList al = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">Connections.syncchronizedList(al);</span><br></pre></td></tr></table></figure>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li><strong>效率低下的HashTable,同Vector类似,它被HashMap替代掉了</strong> <blockquote>
<p>HashTable底层是通过synchronized关键字来实现的,虽然线程安全,但是在高并发的情况下,效率却超级低,因为当一个线程访问HashTable的同步方法时,其他线程拿不到锁,就访问不了它的同步方法,比如线程1使用HashTable的put方法,其他线程不仅不能使用put,就连get()也被阻塞<strong>不可以存储null键值</strong></p>
</blockquote>
</li>
<li><strong>线程不安全的HashMap</strong><blockquote>
<p>在高并发访问的情况下,不会使用HashMap,<strong>线程不安全,但是可以存储null键值</strong></p>
</blockquote>
</li>
</ul>
<p>将HashMap转换成线程安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map map1 = Collections.synchronizedMap(map);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="并发容器J-U-C"><a href="#并发容器J-U-C" class="headerlink" title="并发容器J.U.C"></a>并发容器<strong>J.U.C</strong></h1><h3 id="一-并发List–CopyOnWriteArrayList"><a href="#一-并发List–CopyOnWriteArrayList" class="headerlink" title="一. 并发List–CopyOnWriteArrayList"></a>一. 并发List–CopyOnWriteArrayList</h3><blockquote>
<p>它是ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。</p>
</blockquote>
<ul>
<li>我们着重的关注点是啥呢? 可能会出现线程安全性问题的方法  <strong>set()  add() remove()</strong>,   </li>
</ul>
<h3 id="基本的使用"><a href="#基本的使用" class="headerlink" title="基本的使用;"></a>基本的使用;</h3><blockquote>
<p> 同样实现了List接口,那么其实它的使用和ArrayList完全一样的,只是内部的实现不一样  </p>
</blockquote>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><strong>分析add方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;  <span class="comment">//获取锁ReentrantLock</span></span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Object[] elements = getArray();  <span class="comment">// 获取CopyOnWriteArrayList内部维护的数组</span></span><br><span class="line">          <span class="keyword">int</span> len = elements.length;      </span><br><span class="line">          Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);  <span class="comment">// 复制该数组到 newElements数组里面  并扩容</span></span><br><span class="line">          newElements[len] = e;  <span class="comment">//在数组最后添加新的元素</span></span><br><span class="line">          setArray(newElements); <span class="comment">//让替换掉原来的数组 </span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//添加成功</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到,其实类似读写分离, add()可能会出现线程安全问题,因此给它一把锁,get()不会出现线程安全性问题,因此没有锁,如果非要给get也加上锁,那么在add的时候,就不能get了,因为它拿不到锁对象  </p>
</blockquote>
<p><strong>之所以说是读写分离,读read,读取的原数组,add写的时候,其实不是往原array里面写,而是分如下几步</strong></p>
<ol>
<li>加锁</li>
<li>拷贝原数组,创建新的数组</li>
<li>添加新的元素</li>
<li>新数组替换原数组</li>
<li>释放锁</li>
</ol>
<p><strong>分析remove方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).  Returns the element that was removed from the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>) <span class="comment">//移除最后一个</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>)); </span><br><span class="line">        <span class="keyword">else</span> &#123;      <span class="comment">// 移除其它的,当前元素后面的需要往前移动</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;  <span class="comment">// 移除谁,返回谁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结一下</strong></p>
<ul>
<li>假如说多线程并发的应用中,<strong>绝大部分都是读操作</strong>,那么,<strong>CopyOnWriteArrayList效率明显高</strong>,因为他是读写分离,读没有锁,是在原数组上进行的,写也是线程安全的(加了lock),其中有一点就是它虽然能保证数据的最终是同步的,但是却保证不了实时同步性 </li>
<li>假如说<strong>绝大部分操作是写操作</strong>,可以看到,还是挺吃内存的,数组过大,他的效率可能就不一定比同步容器高,在不知道往里面存储多少数据的情况下,慎用.在高并发的互联网环境下这种操作分分钟就导致故障</li>
</ul>
<hr>
<h3 id="二-并发Set"><a href="#二-并发Set" class="headerlink" title="二.  并发Set"></a>二.  并发Set</h3><ul>
<li>和List步调一致的是,java平台为<strong>set集合提供了CopyOnWriteArraySet</strong>,它实现了set接口,<strong>底层完全依赖CopyOnWriteArrayList</strong>因此,它的特性和CopyOnWriteArrayList一致,同样在<strong>读多写少</strong>的高并发环境下,拥有很高的效率  </li>
<li>同样,在<strong>写多读少</strong>的高并发环境下,我们可以考虑下面的转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Object&gt; set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br></pre></td></tr></table></figure>
<h3 id="三-并发Map"><a href="#三-并发Map" class="headerlink" title="三.  并发Map"></a>三.  并发Map</h3><ul>
<li>同样可以使用Collections获取到一个同步Map,但是这个Map的性能依然不是最优的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedMap();</span><br></pre></td></tr></table></figure>
<ul>
<li>jdk同样提供了一个高效同步Map,<strong>ConcurrentHashMap</strong>  他不允许空值<blockquote>
<p><strong>jdk1.7中ConcurrentHashMap内部实行了锁分离</strong>,分段式存储数据,然后每一段数据都会加上不同步的锁,所以当其中一条线程访问其中一段数据的时候,其他数据仍然可以被别的线程访问,同时,它的get()方法也是无锁的</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>jdk1.8中ConcurrentHashMap内部抛弃了锁分离而使用红黑树实现</strong></p>
</blockquote>
<h3 id="四-并发Queue"><a href="#四-并发Queue" class="headerlink" title="四.  并发Queue"></a>四.  并发Queue</h3><blockquote>
<p>在并发队列上,java提供了两套实现,一个是ConcurrentLinkedQueue的非阻塞型的队列,另一个是BlockingQueue接口,阻塞队列,同样他们继承了Queue接口</p>
</blockquote>
<h3 id="1-ConcurrentLinkQueue-非阻塞队列"><a href="#1-ConcurrentLinkQueue-非阻塞队列" class="headerlink" title="1 . ConcurrentLinkQueue 非阻塞队列"></a>1 . ConcurrentLinkQueue 非阻塞队列</h3><blockquote>
<p>保证了在高并发的情况下,对link底层维护的链表的增删改各个节点的安全性</p>
</blockquote>
<ul>
<li>API和LinkList等完全一样…</li>
</ul>
<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><blockquote>
<p><strong>它通过无锁的方法,底层使用的是UNSAFE实现(保证线程的安全性)</strong><br><strong>入队offer</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the tail of this queue.</span></span><br><span class="line"><span class="comment"> * As the queue is unbounded, this method will never return &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Queue#offer&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);  <span class="comment">// 检查新添加的内容是否为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e); <span class="comment">// 将其放入新节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;  <span class="comment">// 整个一个for循环, 循环遍历链表,寻找适当的位置,插入新节点</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK. //可以看到,在这种会出现线程安全性问题的地方,使用的是cas进行操作,保证了线程的安全性</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">            <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">            <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">            <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 可以看到,casXXX 底层使用的是UNSAFE实现(保证线程的安全性)    </span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casTail</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casHead</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, headOffset, cmp, val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="图解节点的添加过程-在001文件中"><a href="#图解节点的添加过程-在001文件中" class="headerlink" title="图解节点的添加过程,在001文件中"></a>图解节点的添加过程,在001文件中</h1><p><strong>出队</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h3><p>java.util.concurrent<br>接口 BlockingQueue<e><br>类型参数：<br>E - 在此 collection 中保持的元素类型<br>所有超级接口：<br>Collection<e>, Iterable<e>, Queue<e><br>所有已知子接口：<br>BlockingDeque<e><br>所有已知实现类：<br>ArrayBlockingQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue </e></e></e></e></e></p>
<p>主要应用场景:<br><strong>生产者和消费者模式</strong></p>
<p><strong>BlockingQueue是一个接口,因此我们学习ArrayBlockingQueue</strong>,它的底层维护着一个数组的阻塞队列</p>
<blockquote>
<p>一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。 </p>
</blockquote>
<blockquote>
<p>此类支持对等待的生产者线程和使用者线程进行排序的可选公平策略。默认情况下，不保证是这种排序。然而，通过将公平性 (fairness) 设置为 true 而构造的队列允许按照 FIFO 顺序访问线程。公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”。 </p>
</blockquote>
<blockquote>
<p>此类及其迭代器实现了 Collection 和 Iterator 接口的所有可选 方法。 </p>
</blockquote>
<p>既然叫阻塞队列,也就是说,他支持在多线程的条件下,<strong>多线程并发添加移除数组的元素,会被阻塞等待,而不会抛出空值异常或者报错,且数组的长度不可变</strong></p>
<ul>
<li>两种情况发生阻塞<ul>
<li>队列满的时候,进行入队操作,也就是说,队列满了,但是有一个线程往队列里面put的时候,他会被阻塞,除非有别的线程做了take的操作</li>
<li>队列为空,进行出队操作  </li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>可阻塞方法</th>
<th>描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td>put</td>
<td>将指定元素插入此队列中，<strong>将等待可用的空间（如果有必要）。</strong></td>
</tr>
<tr>
<td>take</td>
<td>获取并移除此队列的头部，<strong>在元素变得可用之前一直等待（如果有必要）。</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>可以直接使用它,实现消费者生产者模式,他的底层是用Condition ReentrantLock实现的–,方法被lock()和unlock()锁住, 数组满就await , 出队后signal</p>
</blockquote>
<table>
<thead>
<tr>
<th>不发生阻塞</th>
<th>描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛出 <strong>IllegalStateException</strong></td>
</tr>
<tr>
<td>remove</td>
<td>从此队列中移除指定元素的单个实例（如果存在）。同样会抛异常</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>不发生阻塞</th>
<th>描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td>offer</td>
<td>将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，<strong>如果当前没有可用的空间，则返回 false。</strong></td>
</tr>
<tr>
<td>poll</td>
<td>获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。<strong>没有元素,返回null</strong></td>
</tr>
</tbody>
</table>
<hr>
<h3 id="五-并发Deque"><a href="#五-并发Deque" class="headerlink" title="五 .并发Deque"></a>五 .并发Deque</h3><p>jdk1.6开始java提供的双端队列<strong>Deque(Double Ended Queue)</strong>允许在队列的头部或者尾部进行入队或者出队的操作.<br>他是是实现类:  </p>
<ul>
<li>ArrayDeque<ul>
<li>使用数组实现了双端队列,拥有更好的随机访问性,但是当队列的增大时,他需要重新分配内存,然后进行数组的复制 </li>
</ul>
</li>
<li>LinkedList<ul>
<li>使用链表实现了双端队列,因此它相对于ArrayDeque来说,没有了内存调整,数组复制的负担<blockquote>
<p><strong>无论是ListedList还是ArratDeque,都是线程不安全的</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>LinkedBlockingDeque<blockquote>
<p>线程安全,但是它没有进行读写分离,也就说,同一时间,只允许一条线程对其操作,因此在并发中,<strong>它的性能,远远底于ConcurrentLinkQueue</strong></p>
</blockquote>
</li>
</ul>
<hr>
<p><strong>参考 博文</strong><br><a href="https://www.cnblogs.com/yueshutong/p/9696216.html" target="_blank" rel="noopener">你不就像风一样</a></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/01/26/多线程七 AQS/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          多线程七 AQS
        
      </div>
    </a>
  
  
    <a href="/2019/01/20/多线程五 线程池/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">多线程五 线程池</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<div class="social-share"></div>

	<!--  css & js -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
</div>





<div class="livere">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zODU3Mi8xNTEwMA==">
        <script type="text/javascript">
       (function(d, s) {
           var j, e = d.getElementsByTagName(s)[0];

           if (typeof LivereTower === 'function') { return; }

           j = d.createElement(s);
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;

           e.parentNode.insertBefore(j, e);
       })(document, 'script');
        </script>
    <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 赐我白日梦
    	</div>
      	<div class="footer-right">
      		<p>
            <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten    
            </p>
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/mobile.js"></script>
<script src="/js/main.js"></script>


<!--百度统计的代码-->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b759ac2a7fa45129e3ef060bf68259f0";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </div>
</body>
</html>