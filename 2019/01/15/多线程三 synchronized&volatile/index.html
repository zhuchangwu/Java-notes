<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="多线程,">










<meta name="description" content="synchronized(JVM实现的锁) 通过这两个关键字,我们可以很容易的实现同步多个任务的行为,可以实现同一时刻,只能有一条线程去访问共享资源">
<meta name="keywords" content="多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程三 synchronized&amp;volatile">
<meta property="og:url" content="http://yoursite.com/2019/01/15/多线程三 synchronized&volatile/index.html">
<meta property="og:site_name" content="赐我白日梦">
<meta property="og:description" content="synchronized(JVM实现的锁) 通过这两个关键字,我们可以很容易的实现同步多个任务的行为,可以实现同一时刻,只能有一条线程去访问共享资源">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-02-16T05:05:56.977Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多线程三 synchronized&amp;volatile">
<meta name="twitter:description" content="synchronized(JVM实现的锁) 通过这两个关键字,我们可以很容易的实现同步多个任务的行为,可以实现同一时刻,只能有一条线程去访问共享资源">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/01/15/多线程三 synchronized&volatile/">





  <title>多线程三 synchronized&volatile | 赐我白日梦</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">赐我白日梦</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/15/多线程三 synchronized&volatile/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Changwu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赐我白日梦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">多线程三 synchronized&volatile</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-15T21:52:06+08:00">
                2019-01-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="synchronized-JVM实现的锁"><a href="#synchronized-JVM实现的锁" class="headerlink" title="synchronized(JVM实现的锁)"></a>synchronized(JVM实现的锁)</h2><blockquote>
<p>通过这两个关键字,我们可以很容易的实现同步多个任务的行为,可以实现同一时刻,只能有一条线程去访问共享资源<a id="more"></a></p>
</blockquote>
<h3 id="一-修饰普通方法"><a href="#一-修饰普通方法" class="headerlink" title="一: 修饰普通方法"></a>一: 修饰普通方法</h3><h4 id="多个线程-共同去竞争访问-方法内部的变量-永远是线程安全的"><a href="#多个线程-共同去竞争访问-方法内部的变量-永远是线程安全的" class="headerlink" title="多个线程,共同去竞争访问,方法内部的变量,永远是线程安全的!!!"></a>多个线程,共同去竞争访问,<strong>方法内部的变量</strong>,永远是线程安全的!!!</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasSelfPrivateNum</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">add</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;  <span class="comment">//num在方法内部,永远是线程安全的!!!</span></span><br><span class="line">         <span class="keyword">if</span>(name.equals(<span class="string">"a"</span>)&#123;</span><br><span class="line">            num =<span class="number">100</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            num =<span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    System.out.println(<span class="string">"num=="</span>+num);    </span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多个线程-共同去竞争访问对象中的实例变量-可能导致非线程安全"><a href="#多个线程-共同去竞争访问对象中的实例变量-可能导致非线程安全" class="headerlink" title="多个线程,共同去竞争访问对象中的实例变量,可能导致非线程安全"></a>多个线程,共同去竞争访问<strong>对象中的实例变量</strong>,可能导致非线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasSelfPrivateNum</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">0</span>;  <span class="comment">//num是本类的实例变量,可能出现非线程安全问题!!!</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">add</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(name.equals(<span class="string">"a"</span>)&#123;</span><br><span class="line">             num =<span class="number">100</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             num =<span class="number">200</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     System.out.println(<span class="string">"num=="</span>+num);    </span><br><span class="line">         </span><br><span class="line">     &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论:"></a>结论:</h4><blockquote>
<p>只有<strong>共享的资源</strong>才可能出现非线程安全性问题,需要同步化…就像方法内部的变量,根本不可能共享,所以说没必要同步化</p>
</blockquote>
<h4 id="解决非线程安全问解决"><a href="#解决非线程安全问解决" class="headerlink" title="解决非线程安全问解决"></a>解决非线程安全问解决</h4><blockquote>
<p>这一问题引入了<strong>Synchronized</strong>关键字,让出现非线程安全问题的方法,保持前后的同步,让线程拿到<strong>对象锁(this对象锁)</strong>,当某一个线程进去后,其他线程只能等它释放对象锁之后,获取到对象锁在进入同步方法(Synchronized可以保证它修饰的方法实现原子性的操作)</p>
</blockquote>
<blockquote>
<p><strong>拓展</strong>：Ａ线程持有object对象的锁,B线程可以异步的调用object对象中的非Synchronized类型的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasSelfPrivateNum</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">0</span>;  <span class="comment">//num是本类的实例变量,可能出现非线程安全问题!!!</span></span><br><span class="line">  <span class="function">Synchronized <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">add</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(name.equals(<span class="string">"a"</span>)&#123;</span><br><span class="line">             num =<span class="number">100</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             num =<span class="number">200</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     System.out.println(<span class="string">"num=="</span>+num);    </span><br><span class="line">         </span><br><span class="line">     &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="多个对象多个锁"><a href="#多个对象多个锁" class="headerlink" title="多个对象多个锁"></a>多个对象多个锁</h4><blockquote>
<p>比如说,分别给<strong>两个线程</strong>分别去访问<strong>同一个类</strong>的<strong>两个不同不对象</strong>的<strong>同名同步方法</strong>,结果不是顺序执行,而是异步执行的…  </p>
</blockquote>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论:"></a>结论:</h4><blockquote>
<p>关键字Synchronized获取到的锁<strong>全部是对象锁</strong>,而不是把一段代码或者一个方法当作锁!真出现了多个线程访问多个对象,那么JVM就会创建出,多把对象锁…</p>
</blockquote>
<h4 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h4><blockquote>
<p>java中每一个对象都可被当作同步的锁,这些锁就叫做内置锁</p>
</blockquote>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><blockquote>
<p>一个线程进来之后,另一个线程不能进来</p>
</blockquote>
<h3 id="二-修饰代码块"><a href="#二-修饰代码块" class="headerlink" title="二: 修饰代码块"></a>二: 修饰代码块</h3><p>Synchronized的<strong>弊端</strong>:  </p>
<blockquote>
<p>声明方法在某些情况下是有弊端的,比如说A线程抢到了cpu的执行权,在调用同步方法执行某一个比较长的任务的,A还没来得及释放这个对象锁,紧接着B线程抢到了cpu的执行权,他也想去访问A线程访问的方法,然而B线程拿不到这个对象锁,所以被拒绝访问,因此B线程必须等待较长的时间</p>
</blockquote>
<p><strong>同步代码块语法:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object)&#123;</span><br><span class="line">    <span class="comment">//同步执行的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>sychronized</strong>代码块里面的方法是同步的,另一个线程只有等待当前线程执行完这个代码块之后,才能执行此代码块</p>
</blockquote>
<p><strong>使用同步代码块解决同步方法的弊端,提升效率 一半同步一半异步!</strong>–&gt;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> task&#123;</span><br><span class="line">    <span class="comment">//类的实例属性  --&gt; 共享资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ....  <span class="comment">// 非共享资源</span></span><br><span class="line">        ....  <span class="comment">// 非共享资源</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            a++；</span><br><span class="line">            b++；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedExceotion e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看到,我们只是把可能出现非线程的共享资源放在同步代码块中…   </p>
</blockquote>
<blockquote>
<p><strong>当一个线程访问object的一个Synchronized(this){}同步代码块里面的内容时,另一个线程可以访问此object对象中的非synchronized代码块!!!</strong></p>
</blockquote>
<blockquote>
<p>也就是一半同步,一半异步,<strong>不在同步代码块中的代码,就是异步执行,在同步代码块中的代码,就是同步执行!</strong></p>
</blockquote>
<h4 id="Synchronized代码块的本身具有同步性-而且-Synchronized代码块之间也具有同步性"><a href="#Synchronized代码块的本身具有同步性-而且-Synchronized代码块之间也具有同步性" class="headerlink" title="Synchronized代码块的本身具有同步性,而且,Synchronized代码块之间也具有同步性!"></a>Synchronized代码块的本身具有同步性,而且,Synchronized代码块之间也具有同步性!</h4><blockquote>
<p>当一个线程访问object对象中的Synchronized代码块的时候,其他的任何线程对object的其他任何Synchronized同步代码块的访问也是阻塞的,<strong>这也说明Synchronized同步代码块和Synchronized修饰的方法一样,使用的对象监视器是一个</strong></p>
</blockquote>
<h4 id="将任意对象-作为对象监视器"><a href="#将任意对象-作为对象监视器" class="headerlink" title="将任意对象,作为对象监视器:"></a>将任意对象,作为对象监视器:</h4><blockquote>
<p>Synchronized(<strong>非this对象</strong>){} 同步代码块可以是任意对象,这个<strong>非this对象</strong>大多数是,<strong>方法的参数,类的实例变量</strong></p>
</blockquote>
<h4 id="Synchronized-非this对象-优点"><a href="#Synchronized-非this对象-优点" class="headerlink" title="Synchronized(非this对象){}优点"></a>Synchronized(<strong>非this对象</strong>){}优点</h4><blockquote>
<p> 如果一个类中有很多的Synchronized同步方法,虽然可以实现同步,但是,会发生阻塞而降低效率,因为<strong>所有的Synchronized同步方法</strong>,他们拥有的都是<strong>this锁</strong>,而<strong>Synchronized(非this对象){}同步代码块</strong>可以使用的是<strong>非this锁</strong>,拥有不同的锁,因此他们<strong>两者之间是异步执行</strong>的,对他们自己来说<strong>又是同步执行</strong>,提升了效率</p>
</blockquote>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点:"></a>注意点:</h4><blockquote>
<p>同步代码块放在非同步Synchronized方法中进行声明,不能保证调用方法的线程执行同步,因为线程调用方法的顺序是无序的,虽然在同步代码块中执行的顺序依然有序,但如果有分支逻辑判断(逻辑判断没有在同步代码块中),就可能会出现脏读</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//创建一个只能存储一个元素的集合...</span></span><br><span class="line">  List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsafe</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(list.size()&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          <span class="keyword">synchronized</span>()&#123; </span><br><span class="line">          list.add(<span class="string">"a"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此段代码就会出现脏读...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法: 同步化</span></span><br><span class="line">  List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsafe</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(list.size()&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          <span class="keyword">synchronized</span>()&#123; </span><br><span class="line">          list.add(<span class="string">"a"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Synchronized-非this对象-总结"><a href="#Synchronized-非this对象-总结" class="headerlink" title="Synchronized(非this对象){}总结:"></a>Synchronized(<strong>非this对象</strong>){}总结:</h4><ol>
<li>在多个线程持有”对象监视器”为<strong>同一个对象的前提下</strong>,同一时间,只有一个线程可以执行synchronized(非this对象){}同步代码块中的代码.</li>
<li>同一时间,线程想去执行synchronized(非this对象){}同步代码块里面的代码,它必须拿到这个非this对象</li>
<li>其他线程调用Synchronized(非this##### 象X){}中的X的同步代码块,同步方法,依然是线程安全的.</li>
<li>在多线程访问的情况下,拥有不同对象监视器的Synchronized(){}同步代码块之间是异步执行的</li>
</ol>
<h3 id="三-修饰静态XX"><a href="#三-修饰静态XX" class="headerlink" title="三: 修饰静态XX"></a>三: 修饰静态XX</h3><h4 id="Synchronized-public-static-void-……"><a href="#Synchronized-public-static-void-……" class="headerlink" title="Synchronized public static void ……"></a>Synchronized public static void ……</h4><blockquote>
<p>Synchronized方法同样可以修饰静态方法,运行的结果证明它同样可以实现线程安全,顺序执行,但是<strong>Synchronized修饰普通方法</strong> 和 <strong>Synchronized修饰静态方法</strong>是有<strong>本质上的区别的</strong>,<strong>Synchronized修饰静态方法</strong>实际上是给<strong>Class类上锁</strong> 而前者是给<strong>this对象</strong>上锁.</p>
</blockquote>
<blockquote>
<p>换言之,两个自身顺序执行,同时出现则异步执行,(锁不同)</p>
</blockquote>
<h3 id="四-修饰同步代码块"><a href="#四-修饰同步代码块" class="headerlink" title="四 修饰同步代码块"></a>四 修饰同步代码块</h3><blockquote>
<p>Synchronized(类名.class){…}<br>作用和其修饰静态方法一样</p>
</blockquote>
<h3 id="五-synchronized锁重入"><a href="#五-synchronized锁重入" class="headerlink" title="五 . synchronized锁重入"></a>五 . synchronized锁重入</h3><ul>
<li>synchronized关键字具有锁重入的功能,也就是说,当一个线程拿到锁对象之后,当它在本synchronized方法中访问本类对象的其他synchronized方法时,它是可以重复拿到锁的!</li>
</ul>
<h3 id="六-出现异常锁自动释放"><a href="#六-出现异常锁自动释放" class="headerlink" title="六. 出现异常锁自动释放"></a>六. 出现异常锁自动释放</h3><ul>
<li>在synchronized修饰的同步方法中,若在运行时,出现了异常,对象锁会自动释放,意味着其他线程可以直接在此获取到对象锁</li>
</ul>
<h3 id="七-数据类型String的常量池特性"><a href="#七-数据类型String的常量池特性" class="headerlink" title="七. 数据类型String的常量池特性"></a>七. 数据类型String的常量池特性</h3><ul>
<li>JVM中具有String常量池缓存的功能,如下一段代码返回true</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> mainString[] avgs()&#123;</span><br><span class="line">    String a =<span class="string">"a"</span>;</span><br><span class="line">    String b = <span class="string">"a"</span>;</span><br><span class="line">    System.out.println(a==b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也就是意味着,假如在两个线程给一个Synchronized同步代码块中传递进<strong>同样的字符串</strong>,也就意味着,他们要<strong>去竞争同一把锁</strong>,难免会出现阻塞的情况.<strong>所以绝大多数情况下,我们是不使用String字符串,来当作锁对象的</strong></p>
<h3 id="八-同步Synchronized方法的无限循环的等待和解决"><a href="#八-同步Synchronized方法的无限循环的等待和解决" class="headerlink" title="八. 同步Synchronized方法的无限循环的等待和解决"></a>八. 同步Synchronized方法的无限循环的等待和解决</h3><p>同步方法synchronized同步方法,容易造成死循环,如下代码,method永远不可能得到执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"methodA Begin"</span>);</span><br><span class="line">          <span class="keyword">boolean</span> tag = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">while</span>(tag)&#123;&#125;</span><br><span class="line">          System.out.println(<span class="string">"methodA end"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"methodB Begin"</span>);</span><br><span class="line">          System.out.println(<span class="string">"methodB end"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用同步代码块解决无限循环问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">         Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">         <span class="keyword">synchronized</span>(o1)&#123;</span><br><span class="line">             System.out.println(<span class="string">"methodA Begin"</span>);</span><br><span class="line">             <span class="keyword">boolean</span> tag = <span class="keyword">true</span>;</span><br><span class="line">             <span class="keyword">while</span>(tag)&#123;&#125;</span><br><span class="line">             System.out.println(<span class="string">"methodA end"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span>(o2)&#123;</span><br><span class="line">        System.out.println(<span class="string">"methodB Begin"</span>);</span><br><span class="line">        System.out.println(<span class="string">"methodB end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="九-多线程的死锁"><a href="#九-多线程的死锁" class="headerlink" title="九 多线程的死锁"></a>九 多线程的死锁</h3><ul>
<li>多线程的死锁就是说,已经准备就绪的线程们在等待一个根本不可能被释放的锁,从而导致所有的线程任务都无法继续完成,导致了线程的假死,死锁是必须要避免的问题</li>
</ul>
<p>如下代码死锁现象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demoSiSuo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demoSiSuo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span>  Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span>  Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (username.equals(<span class="string">"a"</span>))&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"a"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                    <span class="comment">//do something</span></span><br><span class="line">                    System.out.println(<span class="string">"接着lock1 lock2的代码执行了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (username.equals(<span class="string">"b"</span>))&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                System.out.println(<span class="string">"b"</span>);</span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                    <span class="comment">//do something</span></span><br><span class="line">                    System.out.println(<span class="string">"接着lock2 lock1的代码执行了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demoSiSuo demoSiSuo = <span class="keyword">new</span> demoSiSuo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demoSiSuo.set(<span class="string">"a"</span>);</span><br><span class="line">            demoSiSuo.run();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demoSiSuo.set(<span class="string">"b"</span>);</span><br><span class="line">            demoSiSuo.run();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用JDK自带的检查死锁的工具</strong>  </p>
<p>在cmd窗口切换到bin目录,输入指令jps 找到正在运行的实例id, 输入 jstack -l [id] 可查看到<br><strong>Found 1 deadlock.</strong> </p>
<h3 id="十-锁对象的改变"><a href="#十-锁对象的改变" class="headerlink" title="十 . 锁对象的改变"></a>十 . 锁对象的改变</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">myService</span></span>&#123;</span><br><span class="line">         <span class="keyword">private</span> String lock=<span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                 lock=<span class="string">"456"</span>;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName());</span><br><span class="line">                 Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                 System.out.println(Thread.currentThread().getName()+<span class="string">"end"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        myService  j = <span class="keyword">new</span> myService();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                j.method();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                j.method();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果<br>Thread-0<br>Thread-1<br>Thread-0end<br>Thread-1end  </p>
<ul>
<li>Thread-0把当前对象的lock属性给改了,然后自己休眠, Thread-1  拿到的是456,所以异步执行</li>
</ul>
<p><strong>当注释Thread.sleep(1000);</strong>结果如下<br>Thread-0  同步执行<br>Thread-0end<br>Thread-1<br>Thread-1end  </p>
<ul>
<li>去掉注释,他们同时抢到的锁都是123,</li>
</ul>
<blockquote>
<p>对象锁改变,依然是遵循<strong>高并发下 拥有同一把锁的同步方法或代码块会阻塞,拥有不同锁,是不会阻塞的</strong></p>
</blockquote>
<ul>
<li><strong>此外,只要锁对象不变,即使锁对象的属性改变了,运行的结果依然是同步的</strong></li>
</ul>
<h3 id="十一-从字节码的角度理解Synchronized关键字的实现原理"><a href="#十一-从字节码的角度理解Synchronized关键字的实现原理" class="headerlink" title="十一. 从字节码的角度理解Synchronized关键字的实现原理"></a>十一. 从字节码的角度理解Synchronized关键字的实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">         <span class="keyword">this</span>.value++;</span><br><span class="line">         <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过-javap-verbose-jishuqi-class-查看同步代码块部分的字节码"><a href="#通过-javap-verbose-jishuqi-class-查看同步代码块部分的字节码" class="headerlink" title="通过 javap -verbose jishuqi.class 查看同步代码块部分的字节码"></a>通过 javap -verbose jishuqi.class 查看同步代码块部分的字节码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public int add();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=3, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dup</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: monitorenter  </span><br><span class="line">         4: aload_0</span><br><span class="line">         5: dup</span><br><span class="line">         6: getfield      #2                  // Field value:I</span><br><span class="line">         9: iconst_1</span><br><span class="line">        10: iadd</span><br><span class="line">        11: putfield      #2                  // Field value:I</span><br><span class="line">        14: aload_0</span><br><span class="line">        15: getfield      #2                  // Field value:I</span><br><span class="line">        18: aload_1</span><br><span class="line">        19: monitorexit</span><br><span class="line">        20: ireturn</span><br><span class="line">        21: astore_2</span><br><span class="line">        22: aload_1</span><br><span class="line">        23: monitorexit</span><br><span class="line">        24: aload_2</span><br><span class="line">        25: athrow</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             4    20    21   any</span><br><span class="line">            21    24    21   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">        line 8: 4</span><br><span class="line">        line 9: 14</span><br><span class="line">        line 10: 21</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      26     0  this   Lcom/atGongDa/MultiThreading/Synchronized/jiShuQi;</span><br><span class="line">      StackMapTable: number_of_entries = 1</span><br><span class="line">        frame_type = 255 /* full_frame */</span><br><span class="line">          offset_delta = 21</span><br><span class="line">          locals = [ class com/atGongDa/MultiThreading/Synchronized/jiShuQi, class java/lang/Object ]</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br></pre></td></tr></table></figure>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解:"></a>理解:</h4><blockquote>
<p>synchronized代码块被<strong>monitorenter</strong>和<strong>monitorexit</strong>包围,他俩之间做出了大量的判断,字节码并不是一行一行按顺序执行的,可能碰到ifle会跳转,碰到异常,查询异常表后跳转…最后锁一定会被释放</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3: monitorenter  </span><br><span class="line">`  ....</span><br><span class="line">23: monitorexit</span><br></pre></td></tr></table></figure>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="1-volatile概览"><a href="#1-volatile概览" class="headerlink" title="1 volatile概览:"></a>1 volatile概览:</h3><ul>
<li>是一个轻量级的锁,保证了变量在多个线程中的可见性</li>
</ul>
<p>volatile通过<strong>加入内存屏障</strong>和<strong>禁止重排序</strong>优化来实现</p>
<ul>
<li><p>对volatile变量进行写操作的时候,会在写操作前加入一条store屏障指令,将本地内存中的共享变量的值,刷新会主内存</p>
</li>
<li><p>对volatile变量进行读操作的时候,会在读操作前加入一条load屏障指令,从主内存中读</p>
</li>
</ul>
<h3 id="2-volatile-amp-synchronized"><a href="#2-volatile-amp-synchronized" class="headerlink" title="2 volatile &amp; synchronized"></a>2 volatile &amp; synchronized</h3><ul>
<li>volatile 修饰类的属性,它的作用就是 <strong>强制从公共堆栈中获取变量的值,而不是从线程的私有数据栈中获取变量的值</strong></li>
<li>volatile 只能修饰属性,—–synchronized修饰方法,代码块</li>
<li>多线程访问volatile,<strong>不会发生阻塞</strong> ,——Synchronized会发生堵塞</li>
<li>volatile 保证了线程的数据的可见性,也就是说,他可以保证线程始终如一的获取volatile属性的最新值!但是如果在对这个变量进行了其他操作,比如i++,那么volatile就变的没有任何意义,非线程安全.  <ul>
<li>i++是非原子性操作:<ul>
<li>从内存中取出i的值</li>
<li>计算i的值</li>
<li>将i的值写回内存</li>
</ul>
</li>
</ul>
</li>
<li>synchronized保证了线程的同步性,安全性</li>
<li>volatile不具备原子性—-Synchronized可以实现原子性</li>
<li><strong>synchronized代码块拥有volatile关键字的特性</strong>,既能保证数据的可见性,又能保证互斥性</li>
</ul>
<blockquote>
<p>再次重申:<strong>volatile解决的是变量在多个线程之间的可见性, synchronized解决的是多个线程之间访问资源的同步性</strong></p>
</blockquote>
<blockquote>
<p>我们完全可以使用Synchronized替代volatile 但是 后者不一定能替代前者,比如在获取变量的时候进行++操作,非原子性,导致非线程安全!</p>
</blockquote>
<h3 id="3-前行知识补充"><a href="#3-前行知识补充" class="headerlink" title="3 前行知识补充:"></a>3 前行知识补充:</h3><blockquote>
<p>把JVM的运行环境该变成 -server, 当JVM运行在Server环境下,为了提高线程的效率,线程获取到的 类的属性值时,始终在自己的私有堆栈中获取,但是当它去更改类的属性值的时候,改变的确是公共堆栈中的属性!,<strong>也就是说,它获取到的属性值,就是一开始从公共堆栈中复制过去的值,不曾,也不能修改</strong>,</p>
</blockquote>
<h3 id="4-那么想同步数据怎么办"><a href="#4-那么想同步数据怎么办" class="headerlink" title="4 那么想同步数据怎么办?"></a>4 那么想同步数据怎么办?</h3><p>这也是volatile关键字出现的必要,<strong>保证了多个线程之间 属性的可见性</strong> –&gt; <strong>强制从公共堆栈中获取变量的值,而不是从线程的私有数据栈中获取变量的值</strong></p>
<h3 id="4-1-volatile解决同步死循环"><a href="#4-1-volatile解决同步死循环" class="headerlink" title="4.1 volatile解决同步死循环"></a>4.1 volatile解决同步死循环</h3><p>直接运行下面一段代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> tag= <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(tag==<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"methodA  end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTag</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tag=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo01 demo01 = <span class="keyword">new</span> demo01();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo01.methodA();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo01.setTag();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main endl..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接运行结果:<br>main endl…<br>methodA  end…  </p>
<blockquote>
<p>更改JVM运行参数  -server再次运行</p>
</blockquote>
<p>结果:<br>main endl;</p>
<blockquote>
<p>更改JVM运行参数  -server再次运行,并将tag用volalite修饰</p>
</blockquote>
<p>结果:<br>main endl…<br>methodA  end…<br>验证了volatile实现了多个线程之间数据的可见性</p>
<h3 id="4-2验证Synchronized代码块实现了数据的可见性"><a href="#4-2验证Synchronized代码块实现了数据的可见性" class="headerlink" title="4.2验证Synchronized代码块实现了数据的可见性"></a>4.2验证Synchronized代码块实现了数据的可见性</h3><p>将mathodA()进行如下修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(tag==<span class="keyword">true</span>)&#123;</span><br><span class="line">            String string = <span class="keyword">new</span> String();</span><br><span class="line">            <span class="keyword">synchronized</span> (string)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"methodA  end..."</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-volatile常用的情景"><a href="#4-3-volatile常用的情景" class="headerlink" title="4.3 volatile常用的情景"></a>4.3 volatile常用的情景</h3><blockquote>
<p>使用volatile做标记变量,如下代码,假设线程2执行前必须要等线程1做好初始化工作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> tag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1: </span></span><br><span class="line">Context = loadContext();</span><br><span class="line">tag=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!tag)&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithContext();</span><br></pre></td></tr></table></figure>
<h3 id="4-4-用于安全发布对象时的双重检测禁止指令的重排序"><a href="#4-4-用于安全发布对象时的双重检测禁止指令的重排序" class="headerlink" title="4.4 用于安全发布对象时的双重检测禁止指令的重排序"></a>4.4 用于安全发布对象时的双重检测禁止指令的重排序</h3><h3 id="5-volatile原理"><a href="#5-volatile原理" class="headerlink" title="5 volatile原理"></a>5 volatile原理</h3><p>硬盘–&gt;内存–&gt;CPU的缓存</p>
<p>volatile关键字起作用,依赖的是<strong>Lock指令</strong></p>
<ul>
<li>在多处理器的系统上:<ul>
<li>将处理器<strong>缓存行</strong>里面的内容,写回到系统内存</li>
<li>这个操作同时会使其他线程cpu的缓存里面存储的对应数据失效,故,不得不重新去内存中加载最新的数据</li>
</ul>
</li>
</ul>
<p>上图,从左到右,运算速度越来越高,每个线程都有属于自己的缓存,</p>
<blockquote>
<p>大量使用volatile关键字,会降低CPU缓存的使用量,增加内存的储存量,进而导致程序运行效率降低!</p>
</blockquote>
<hr>
<p><strong>参考书籍&lt;&lt;java多线程编程核心技术&gt;&gt; 高洪岩著</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/多线程/" rel="tag"><i class="fa fa-tag"></i> 多线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/10/多线程二 基本技能/" rel="next" title="多线程二 基本技能">
                <i class="fa fa-chevron-left"></i> 多线程二 基本技能
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/17/多线程四 线程之间的通信/" rel="prev" title="多线程四 线程之间的通信">
                多线程四 线程之间的通信 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="Changwu">
            
              <p class="site-author-name" itemprop="name">Changwu</p>
              <p class="site-description motion-element" itemprop="description">随笔</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-JVM实现的锁"><span class="nav-number">1.</span> <span class="nav-text">synchronized(JVM实现的锁)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-修饰普通方法"><span class="nav-number">1.1.</span> <span class="nav-text">一: 修饰普通方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多个线程-共同去竞争访问-方法内部的变量-永远是线程安全的"><span class="nav-number">1.1.1.</span> <span class="nav-text">多个线程,共同去竞争访问,方法内部的变量,永远是线程安全的!!!</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个线程-共同去竞争访问对象中的实例变量-可能导致非线程安全"><span class="nav-number">1.1.2.</span> <span class="nav-text">多个线程,共同去竞争访问对象中的实例变量,可能导致非线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结论"><span class="nav-number">1.1.3.</span> <span class="nav-text">结论:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决非线程安全问解决"><span class="nav-number">1.1.4.</span> <span class="nav-text">解决非线程安全问解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个对象多个锁"><span class="nav-number">1.1.5.</span> <span class="nav-text">多个对象多个锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结论-1"><span class="nav-number">1.1.6.</span> <span class="nav-text">结论:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内置锁"><span class="nav-number">1.1.7.</span> <span class="nav-text">内置锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#互斥锁"><span class="nav-number">1.1.8.</span> <span class="nav-text">互斥锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-修饰代码块"><span class="nav-number">1.2.</span> <span class="nav-text">二: 修饰代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized代码块的本身具有同步性-而且-Synchronized代码块之间也具有同步性"><span class="nav-number">1.2.1.</span> <span class="nav-text">Synchronized代码块的本身具有同步性,而且,Synchronized代码块之间也具有同步性!</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将任意对象-作为对象监视器"><span class="nav-number">1.2.2.</span> <span class="nav-text">将任意对象,作为对象监视器:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-非this对象-优点"><span class="nav-number">1.2.3.</span> <span class="nav-text">Synchronized(非this对象){}优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意点"><span class="nav-number">1.2.4.</span> <span class="nav-text">注意点:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-非this对象-总结"><span class="nav-number">1.2.5.</span> <span class="nav-text">Synchronized(非this对象){}总结:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-修饰静态XX"><span class="nav-number">1.3.</span> <span class="nav-text">三: 修饰静态XX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-public-static-void-……"><span class="nav-number">1.3.1.</span> <span class="nav-text">Synchronized public static void ……</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-修饰同步代码块"><span class="nav-number">1.4.</span> <span class="nav-text">四 修饰同步代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五-synchronized锁重入"><span class="nav-number">1.5.</span> <span class="nav-text">五 . synchronized锁重入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六-出现异常锁自动释放"><span class="nav-number">1.6.</span> <span class="nav-text">六. 出现异常锁自动释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七-数据类型String的常量池特性"><span class="nav-number">1.7.</span> <span class="nav-text">七. 数据类型String的常量池特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八-同步Synchronized方法的无限循环的等待和解决"><span class="nav-number">1.8.</span> <span class="nav-text">八. 同步Synchronized方法的无限循环的等待和解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九-多线程的死锁"><span class="nav-number">1.9.</span> <span class="nav-text">九 多线程的死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十-锁对象的改变"><span class="nav-number">1.10.</span> <span class="nav-text">十 . 锁对象的改变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十一-从字节码的角度理解Synchronized关键字的实现原理"><span class="nav-number">1.11.</span> <span class="nav-text">十一. 从字节码的角度理解Synchronized关键字的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过-javap-verbose-jishuqi-class-查看同步代码块部分的字节码"><span class="nav-number">1.11.1.</span> <span class="nav-text">通过 javap -verbose jishuqi.class 查看同步代码块部分的字节码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#理解"><span class="nav-number">1.11.2.</span> <span class="nav-text">理解:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile"><span class="nav-number">2.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-volatile概览"><span class="nav-number">2.1.</span> <span class="nav-text">1 volatile概览:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-volatile-amp-synchronized"><span class="nav-number">2.2.</span> <span class="nav-text">2 volatile &amp; synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-前行知识补充"><span class="nav-number">2.3.</span> <span class="nav-text">3 前行知识补充:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-那么想同步数据怎么办"><span class="nav-number">2.4.</span> <span class="nav-text">4 那么想同步数据怎么办?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-volatile解决同步死循环"><span class="nav-number">2.5.</span> <span class="nav-text">4.1 volatile解决同步死循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2验证Synchronized代码块实现了数据的可见性"><span class="nav-number">2.6.</span> <span class="nav-text">4.2验证Synchronized代码块实现了数据的可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-volatile常用的情景"><span class="nav-number">2.7.</span> <span class="nav-text">4.3 volatile常用的情景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-用于安全发布对象时的双重检测禁止指令的重排序"><span class="nav-number">2.8.</span> <span class="nav-text">4.4 用于安全发布对象时的双重检测禁止指令的重排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-volatile原理"><span class="nav-number">2.9.</span> <span class="nav-text">5 volatile原理</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Changwu</span>

  
</div>



  <div class="powered-by">
  <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  </div>

  <!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动
  </div>


  

  
    <span class="post-meta-divider">|</span>
  

  
    <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>
-->





        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>